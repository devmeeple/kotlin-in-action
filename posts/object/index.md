## 23. 예외

> 'exception'은 'I take exception to that'에 있는 exception과 같은 뜻으로 쓰인다.

- 예외(exception) 기초
    - 예외 상황과 일반적인 문제 구분하기
    - 참고: 6부 실행 방지하기
- 예외 상황에는 처리를 계속할 수 없다. 현재 상황에서 벗아나, 문제를 바깥쪽 맥락으로 내보내기가 최선이다.
- 예외는 오류가 발생한 지점에서 '던져지는' 객체다.
- 예외를 잡아내지(catch) 않으면 프로그램이 중단되면서 예외에 대한 상세 정보가 들어 있는 스택 트레이스(stack trace)가 출력된다.
- 스택 트레이스는 예외가 발생한 파일과 위치 등 상세 정보를 출력한다.
    - 문제 해결의 핵심, 실마리.
- 141 예제

**<참고 자료>**

- [김영한  '스프링 DB 1편 - 데이터 접근 핵심 원리'](https://inf.run/AomUA)
    - 김영한 자바 중급
- 에러가 무섭지 않게 되는 책
- [37. 널이 될 수 있는 타입]

## 24. 리스트

> List는 컨테이너(container), 즉 다른 객체를 담는 객체에 속한다.

- 컨테이너는 컬렉션이라고도 한다.
- `List`는 표준 코틀린 패키지에 들어있다. `import`가 필요 없다.
- 리스트 사용 예제
    - 대부분의 프로그래밍 언어와 마찬가지로 코틀린도 0부터 인덱스를 시작한다.
    - 코틀린과 같은 언어에서는 원소를 한 번에 하나만 선택하지 않고 `in`을 사용해 컨테이너 전체에 대해 이터레이션 한다. 이터레이션을 사용하면 1 차이로 인한 오류를 없앨 수 있다. ✅
    - `List`의 마지막 원소의 인덱스보다 더 큰 인덱스를 사용하면 `ArrayIndexOutOfBoudException`을 던진다.
    - `sort` vs. `sorted` ✅ 145

### 24.1 파라미터화 타입

- 타입 추론 사용하기는 좋은 습관이다. 코드를 더 깔끔하고 읽기 쉽게 만들어준다.
- 타입 파라미터는 '파라미터 타입의 객체를 담는다'는 행동을 표현하는 방법이다.
    - `List<Int>`: 정수형 컨테이너
- 함수의 반환 타입을 명시해서 의도를 전달하면, 코틀린은 의도에 맞는지 강제해 주고 검증을 돕는다.

### 24.2 읽기 전용과 가변 List

- 가변 `List`는 명시적으로 선언해야 얻을 수 있다.
    - `listof()`는 읽기 전용 리스트를 만든다. (불변?) ✅
- 생성 시점에 값과 크기를 알 수 없다면 `mutableListOf()`를 사용하자.
- 리스트에 원소를 추가할 때 `add`가 아닌 `+=`도 사용 가능하다. ✅
- `List`는 읽기 전용이다. 내용은 읽을 수 있지만 값을 쓸 수 없다.

## 25. 가변 인자 목록

> `vararg` 키워드는 길이가 변할 수 있는 인자 목록을 만든다.

- `vararg` 키워드를 사용하면 `listOf`처럼 임의의 길이로 인자를 받을 수 있는 함수를 정의할 수 있다.
    - `vararg`는 가변 인자 목록(variable argument list)를 줄인 말이다.
- 함수를 정의할 땐 `vararg` 키워드를 사용한 인자는 최대 1개만 있어야 한다.
    - 어떤 위치에서든 사용할 수 있지만, 보통 마지막 파라미터를 가변 인자로 선언한다.
- `vararg`를 사용하면 함수의 임의의 개수만큼 인자를 전달할 수 있다.
    - 물론 타입은 동일해야 한다.
- 함수 본문에서는 파라미터 이름을 통해 가변 인자에 접근할 수 있다.
    - 파라미터는 `Array`로 취급한다.
- `Array`와 `List`는 언뜻보면 비슷해보인다. 하지만 전혀 다르게 구현된다.
    - `List`: 일반적인 라이브러리 클래스
    - `Array`: 특별한 저수준 지원이 필요 ✅, 다른 언어와 호환을 위해 생겨났다.
- 일상적인 프로그래밍에서 간단한 시퀀스가 필요하다면 `List`를 써라. ✅
    - 서드파티 API가 `Array`를 요구하거나 `vararg`를 다뤄야 하는 경우에만 `Array`를 사용하라.
- `Array`는 항상 가변 객체다.
- `Array`를 (인자 하나로 넘기지 않고) 인자 목록으로 변환하고 싶으면 스프레드 연산자`(*)`를 사용하라.
- 153 원시 타입 배열, 난해하다. 예제가 필요하다.

### 25.1 명령줄 인자

```kotlin
fun main(args: Array<String>) {
    for (a in args) {
        println(a)
    }
}
```

- `args`외에 다른 이름을 지정해도 괜찮다. 하지만 타입은 꼭 `Array<String>`이어야 한다.

**<참고 자료>**

- [Kotlin Docs 'Functions'](https://kotlinlang.org/docs/functions.html)
- [Kotlin Docs 'Arrays'](https://kotlinlang.org/docs/arrays.html)
- [Baeldung 'Varargs and Spread Operator in Kotlin'](https://www.baeldung.com/kotlin/varargs-spread-operator)

## 26. 집합(Set)

> Set은 각각의 값이 오직 하나만 존재할 수 있는 컬렉션이다.

- 자주 사용하는 함수는 `in`과 `constains`다.
- Set 예제
    - 같은 원소를 정복해 넣으면 자동으로 중복을 없애고 하나만 남긴다.
    - 원소 순서는 중요하지 않다. 내부에 같은 원소가 들어 있으면 같은 집합이다.
    - 원소 여부를 검사하기 위해 `in`과 `contains`를 모두 사용한다. ✅ 다른점
    - 일반적인 벤 다이어그램(Venn diagram) 연산을 수행할 수 있다. 부분집합, 합집합, 교집합, 차집합 등
    - 차집합 연산: `subtract`, 뺄셈 연산자`(-)`

## 27. 맵(Map)

> Map은 키(key)와 값(Value)을 연결하고, 키가 주어지면 그 키의 연결된 값을 찾아준다.

- `mapOf()`를 사용해 Map을 만든다.
- `to()`를 사용해 키와 값을 분리한다.
- Map 예제
    - 이터레이션
- `mapOf()`와 `mutableMapOf()`는 원소가 Map에 전달된 순서를 유지한다.
    - 다른 Map 타입에서는 순서를 보장하지 않는다. 💬 `HashMap()`
- Map은 간단하고 작은 데이터베이스와 비슷하다. 키와 값을 연결시키주기 때문에 때로는 연관 배열(associative array)라고 부른다.
    - 물론 데이터베이스에 비교하면 기능이 제한적이지만 매우 유용한 자료구조임은 분명하다.
    - 데이터베이스에 비해 훨씬 더 효율적이다 💬

**<참고 자료>**

- [Kotlin Docs 'Collections overview﻿'](https://kotlinlang.org/docs/collections-overview.html)

## 28. 프로퍼티 접근자

> 프로퍼티 이름을 사용해 프로퍼티를 읽는다. 대입 연산자(=)를 사용해 가변 프로퍼티에 값을 대입한다.

- 코틀린은 함수를 호출해 프로퍼티 읽기와 쓰기 연산을 수행한다.
- 프로퍼티 접근자(property accessor)를 작성해서 프로퍼티 읽기, 쓰기를 커스텀화(customize)하는 방법 배우기
    - 게터와 세터 중 1가지만 정의해도 괜찮다. 물론 2가지 모두 정의도 가능하다.
- 게터(getter): 값 얻기, `get()`
- 세터(setter): 가변 프로퍼티 갱신하기, `set()`
- 프로퍼티를 `private`로 정의하면 접근자 두 접근자 모두 `private`가 된다.
    - 세터를 `private`하고 게터는 `public`으로 할 수도 있다.
- 코틀린 스타일 가이드에서는 계산 비용이 많이 들지 않고 객체 상태가 바뀌지 않는 한 같은 결과를 내놓는 함수의 경우 프로퍼티를 사용하는 편이 낫다고 안내한다.
- 프로퍼티 접근자는 프로퍼티에 대한 일종의 보호수단이다. ✅✅
    - 다양한 객체 지향 언어는 프로퍼티에 대한 접근을 제어하기 위해 물리적인 필드를 `private`으로 정의하는 방식에 의존한다.
    - 프로퍼티 접근자를 사용하면 필드 접근과 같은 방식으로 쉽게 프로퍼티에 접근하도록 허용하면서 동시에 프로퍼티 접근을 제어하거나 변경할 수 있는 코드를 쉽게 추가할 수 있다.
